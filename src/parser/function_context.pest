wrapped_function_context = _{ SOI ~ function_context ~ EOI }

// the comment and whitespace things here will be implied when
// using this in another rule, but they aren't when using it standalone,
// i.e. in tests.
function_context = _{ (COMMENT | WHITESPACE)* ~ (statement ~ ";")* ~ (COMMENT | WHITESPACE)*}

literal = _{ bool_true | bool_false | char_literal | string_literal | float | integer }

bool_true = @{ "true" }
bool_false = @{ "false" }

char_literal = ${ "'" ~ character ~ "'"}
character = @{
    !("\'" | "\\") ~ ANY
    | "\\" ~ ("\'" | "\\" | "n" | "r" | "t" | ("u" ~ "{" ~ ASCII_HEX_DIGIT{4} ~ "}" ))
}

int_digit = _{ ASCII_DIGIT | "_" }
integer = @{ ASCII_NONZERO_DIGIT ~ int_digit* | int_digit }
float = @{
    integer ~ (
        float_fractional_part ~ float_exponent_part?
        | float_exponent_part
    )
}

float_fractional_part = _{ "." ~ int_digit* }
float_exponent_part = _{ ^"e" ~ ("+" | "-")? ~ integer }

string_literal = ${ "\"" ~ string_literal_inner ~ "\"" }
string_literal_inner = @{ string_literal_char* }
string_literal_char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ "{" ~ ASCII_HEX_DIGIT{4} ~ "}")
}

primary = _{ literal | identifier | "(" ~ expression ~ ")" }
unary_minus = _{ "-" }
atom = _{ unary_minus? ~ primary ~ function_call* }

operator = _{ add | subtract | multiply | divide }
add = { "+" }
subtract = { "-" }
multiply = { "*" }
divide = { "/" }

function_call = { "(" ~ function_call_arguments ~  ")"}
function_call_arguments = _{ (expression ~ ",")* ~ expression? }

statement = _{
    let_statement
    | expression
}

let_statement = { "let" ~ identifier ~ type_hint? ~ "=" ~ expression }

expression = {
    atom ~ (operator ~ atom)*
}
